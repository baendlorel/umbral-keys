#pragma once
#include "logger.h"
#include "utils.h"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <unordered_map>
#include <windows.h>

using namespace std;

class Config {
public:
  static unordered_map<string, NativeArray<string>> load() {
    static const WCHAR *h = L"Config::load";

    filesystem::path currentPath =
        filesystem::current_path(); // 获取当前工作目录
    filesystem::path configPath = currentPath / "config.txt"; // 拼接文件名

    cout << "configPath: " << configPath << endl;

    if (!filesystem::exists(configPath)) {
      // 创建并打开文件
      ofstream newFile(configPath);

      // 检查文件是否成功打开
      if (!newFile.is_open()) {
        Logger::Throw(
            I18N{L"在程序文件夹内新建config.txt失败",
                 L"Cannot create 'config.txt' (must be in same folder)"},
            h);
      } else {
        newFile.close();
        Logger::MsgBox(
            I18N{L"config."
                 L"txt已经新建，请打开它编写键盘映射配置。写完保存后再重"
                 L"新打开影键",
                 L"config.txt is created. Please open it and write key maps. "
                 L"After saving it, run UmbralKeys again."});
      }
    }

    ifstream file(configPath);
    if (!file.is_open()) {
      Logger::Throw(I18N{L"无法打开config.txt", L"Cannot open 'config.txt'"},
                    h);
    }

    string rawLine;
    unordered_map<string, NativeArray<string>> umbralMap;
    while (getline(file, rawLine)) {
      string line = regex_replace(rawLine, regex("\\s+"), ""); // 去除注释
      size_t pos = line.find('=');
      if (pos == string::npos) {
        continue;
      }

      string origin = line.substr(0, pos);
      NativeArray<string> umbras = split(line.substr(pos + 1), '+');

      if (!origin.empty() && umbras.size > 0) {
        umbralMap[origin] = umbras;
      }
    }

    if (umbralMap.size() == 0) {
      Logger::Throw(
          I18N{L"未加载到可用的键盘映射配置", L"No valid config found"}, h);
    }

    file.close();
    return umbralMap;
  }
};
